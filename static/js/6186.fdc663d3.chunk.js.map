{"version":3,"file":"static/js/6186.fdc663d3.chunk.js","mappings":"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","sources":["../node_modules/@ffmpeg/ffmpeg/src/browser/defaultOptions.js","../node_modules/@ffmpeg/ffmpeg/src/browser/getCreateFFmpegCore.js","../node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js","../node_modules/@ffmpeg/ffmpeg/src/config.js","../node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js","../node_modules/@ffmpeg/ffmpeg/src/index.js","../node_modules/@ffmpeg/ffmpeg/src/utils/errors.js","../node_modules/@ffmpeg/ffmpeg/src/utils/log.js","../node_modules/@ffmpeg/ffmpeg/src/utils/parseArgs.js"],"sourcesContent":["import pkg from '../../package.json';\n\n/*\n * Default options for browser environment\n */\nconst corePath = typeof process !== 'undefined' && process.env.NODE_ENV === 'development'\n  ? new URL('/node_modules/@ffmpeg/core/dist/ffmpeg-core.js', import.meta.url).href\n  : `https://unpkg.com/@ffmpeg/core@${pkg.devDependencies['@ffmpeg/core'].substring(1)}/dist/ffmpeg-core.js`;\n\nexport default { corePath };\n","/* eslint-disable no-undef */\nimport { log } from '../utils/log';\nimport {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n} from '../utils/errors';\n\n/*\n * Fetch data from remote URL and convert to blob URL\n * to avoid CORS issue\n */\nconst toBlobURL = async (url, mimeType) => {\n  log('info', `fetch ${url}`);\n  const buf = await (await fetch(url)).arrayBuffer();\n  log('info', `${url} file size = ${buf.byteLength} bytes`);\n  const blob = new Blob([buf], { type: mimeType });\n  const blobURL = URL.createObjectURL(blob);\n  log('info', `${url} blob URL = ${blobURL}`);\n  return blobURL;\n};\n\n// eslint-disable-next-line\nexport const getCreateFFmpegCore = async ({\n  corePath: _corePath,\n  workerPath: _workerPath,\n  wasmPath: _wasmPath,\n}) => {\n  // in Web Worker context\n  // eslint-disable-next-line\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    if (typeof _corePath !== 'string') {\n      throw Error('corePath should be a string!');\n    }\n    const coreRemotePath = new URL(_corePath, import.meta.url).href;\n    const corePath = await toBlobURL(\n      coreRemotePath,\n      'application/javascript',\n    );\n    const wasmPath = await toBlobURL(\n      _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n      'application/wasm',\n    );\n    const workerPath = await toBlobURL(\n      _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n      'application/javascript',\n    );\n    if (typeof createFFmpegCore === 'undefined') {\n      return new Promise((resolve) => {\n        globalThis.importScripts(corePath);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      });\n    }\n    log('info', 'ffmpeg-core.js script is loaded already');\n    return Promise.resolve({\n      createFFmpegCore,\n      corePath,\n      wasmPath,\n      workerPath,\n    });\n  }\n  if (typeof _corePath !== 'string') {\n    throw Error('corePath should be a string!');\n  }\n  const coreRemotePath = new URL(_corePath, import.meta.url).href;\n  const corePath = await toBlobURL(\n    coreRemotePath,\n    'application/javascript',\n  );\n  const wasmPath = await toBlobURL(\n    _wasmPath !== undefined ? _wasmPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.wasm'),\n    'application/wasm',\n  );\n  const workerPath = await toBlobURL(\n    _workerPath !== undefined ? _workerPath : coreRemotePath.replace('ffmpeg-core.js', 'ffmpeg-core.worker.js'),\n    'application/javascript',\n  );\n  if (typeof createFFmpegCore === 'undefined') {\n    return new Promise((resolve) => {\n      const script = document.createElement('script');\n      const eventHandler = () => {\n        script.removeEventListener('load', eventHandler);\n        if (typeof createFFmpegCore === 'undefined') {\n          throw Error(CREATE_FFMPEG_CORE_IS_NOT_DEFINED(coreRemotePath));\n        }\n        log('info', 'ffmpeg-core.js script loaded');\n        resolve({\n          createFFmpegCore,\n          corePath,\n          wasmPath,\n          workerPath,\n        });\n      };\n      script.src = corePath;\n      script.type = 'text/javascript';\n      script.addEventListener('load', eventHandler);\n      document.getElementsByTagName('head')[0].appendChild(script);\n    });\n  }\n  log('info', 'ffmpeg-core.js script is loaded already');\n  return Promise.resolve({\n    createFFmpegCore,\n    corePath,\n    wasmPath,\n    workerPath,\n  });\n};\n","const readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\n// eslint-disable-next-line\nexport const fetchFile = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(new URL(_data, import.meta.url).href);\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n","module.exports = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    './ffmpeg',\n    /* Disable interaction mode */\n    '-nostdin',\n    /* Force to override output file */\n    '-y',\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: false,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {},\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {},\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: '',\n  },\n};\n","const { defaultArgs, baseOptions } = require('./config');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n  let customLogger = () => {};\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n  const log = (type, message) => {\n    customLogger({ type, message });\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n  const ts2sec = (ts) => {\n    const [h, m, s] = ts.split(':');\n    return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n  };\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({ duration: d, ratio });\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n        prog({ ratio, time: t });\n      } else if (message.startsWith('video:')) {\n        prog({ ratio: 1 });\n        duration = 0;\n      }\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n      running = false;\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    customLogger = _logger;\n  };\n\n  const setLogging = (_logging) => {\n    logging = _logging;\n  };\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n","require('regenerator-runtime/runtime');\nconst createFFmpeg = require('./createFFmpeg');\nconst { fetchFile } = require('./node');\n\nmodule.exports = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile,\n};\n","const CREATE_FFMPEG_CORE_IS_NOT_DEFINED = (corePath) => (`\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${corePath}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`);\n\nmodule.exports = {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED,\n};\n","let logging = false;\nlet customLogger = () => {};\n\nconst setLogging = (_logging) => {\n  logging = _logging;\n};\n\nconst setCustomLogger = (logger) => {\n  customLogger = logger;\n};\n\nconst log = (type, message) => {\n  customLogger({ type, message });\n  if (logging) {\n    console.log(`[${type}] ${message}`);\n  }\n};\n\nmodule.exports = {\n  logging,\n  setLogging,\n  setCustomLogger,\n  log,\n};\n","module.exports = (Core, args) => {\n  const argsPtr = Core._malloc(args.length * Uint32Array.BYTES_PER_ELEMENT);\n  args.forEach((s, idx) => {\n    const sz = Core.lengthBytesUTF8(s) + 1;\n    const buf = Core._malloc(sz);\n    Core.stringToUTF8(s, buf, sz);\n    Core.setValue(argsPtr + (Uint32Array.BYTES_PER_ELEMENT * idx), buf, 'i32');\n  });\n  return [args.length, argsPtr];\n};\n"],"names":["corePath","pkg","substring","toBlobURL","async","url","mimeType","log","buf","fetch","arrayBuffer","byteLength","blob","Blob","type","blobURL","URL","createObjectURL","getCreateFFmpegCore","_corePath","workerPath","_workerPath","wasmPath","_wasmPath","_ref","WorkerGlobalScope","self","Error","coreRemotePath","import","href","undefined","replace","createFFmpegCore","Promise","resolve","globalThis","importScripts","CREATE_FFMPEG_CORE_IS_NOT_DEFINED","script","document","createElement","eventHandler","removeEventListener","src","addEventListener","getElementsByTagName","appendChild","fetchFile","data","_data","Uint8Array","test","atob","split","map","c","charCodeAt","res","File","reject","fileReader","FileReader","onload","result","onerror","target","error","code","readAsArrayBuffer","module","exports","defaultArgs","baseOptions","logger","progress","require","parseArgs","defaultOptions","version","NO_LOAD","_options","arguments","length","optLog","optProgress","options","Core","ffmpeg","runResolve","runReject","running","customLogger","logging","duration","frames","readFrames","ratio","message","console","ts2sec","ts","h","m","s","parseFloat","parseMessage","parseProgress","prog","startsWith","d","match","fps","t","f","Math","min","time","detectCompletion","setProgress","_progress","setLogger","_logger","setLogging","_logging","load","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","mainName","isLoaded","run","_len","_args","Array","_key","join","args","filter","exit","err","FS","method","_len2","_key2","arg","ret","e","createFFmpeg","setCustomLogger","argsPtr","_malloc","Uint32Array","BYTES_PER_ELEMENT","forEach","idx","sz","lengthBytesUTF8","stringToUTF8","setValue"],"sourceRoot":""}